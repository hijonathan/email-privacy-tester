// Generated by CoffeeScript 1.4.0
(function() {
  var conf, emitter, getNewData, getNewEmailStatus, getNewTestHits, getResults, humanAge, minHumanAge, pg, sendHTML, sendJSON, testCallbackDNS, testCallbackEmail, testCallbackHTTP, tests, util;

  util = require('util');

  pg = require('pg')["native"];

  conf = require("" + __dirname + "/../conf/main.conf");

  tests = require('ept/tests');

  emitter = new (require('events').EventEmitter)();

  emitter.setMaxListeners(100);

  exports.foo = function(req, res) {
    var counter, e, lookupCode, _i, _len, _ref, _results;
    lookupCode = req.params.lookupCode;
    res.set('Content-Type', 'text/plain');
    counter = 0;
    setInterval(function() {
      res.write("" + (++counter) + "\n");
      return res.write(util.inspect(res, true, null));
    }, 1000);
    _ref = ['clientError', 'error', 'connect'];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      _results.push((function() {
        var event;
        event = e;
        req.on(event, function() {
          return console.log("req: " + event);
        });
        return res.on(event, function() {
          return console.log("res: " + event);
        });
      })());
    }
    return _results;
  };

  exports.testCallback = function(req, res) {
    var callbackCode, clientIP, countDown, email, name, onFail, onSuccess, type, _ref, _ref1;
    clientIP = (_ref = req.socket) != null ? _ref.remoteAddress : void 0;
    callbackCode = req.params.callbackCode;
    name = req.params.name;
    if (!clientIP) {
      return;
    }
    _ref1 = [2, null, null], countDown = _ref1[0], email = _ref1[1], type = _ref1[2];
    onSuccess = function() {
      if (type === 'http') {
        testCallbackHTTP(req, res, email, callbackCode, name, clientIP);
      } else if (type === 'email') {
        testCallbackEmail(req, res, email, callbackCode, name);
      } else if (type === 'dns') {
        testCallbackDNS(req, res, email, callbackCode, name);
      }
      if (name === 'script_in_script' || name === 'js') {
        res.set('Content-Type', 'text/plain');
        return res.end("alert('I\\'ve managed to execute javascript in your browser. That is probably a very bad security hole. Please contact me using the contact link on emailprivacytester.com so I can help sort it out.')");
      } else if (name === 'meta_refresh') {
        return sendHTML(res, 'callback_meta_refresh');
      } else {
        res.set('Content-Type', 'text/plain');
        return res.end('');
      }
    };
    onFail = function() {
      if (countDown === -1) {
        return;
      }
      countDown = -1;
      return res.end('');
    };
    getResults('callback_code', callbackCode, function(err, e) {
      if ((err != null) || !(e != null)) {
        return onFail();
      }
      email = e;
      if (--countDown === 0) {
        return onSuccess();
      }
    });
    return tests.get(name, function(t) {
      if (t == null) {
        return onFail();
      }
      type = t.type;
      if (--countDown === 0) {
        return onSuccess();
      }
    });
  };

  testCallbackHTTP = function(req, res, email, callbackCode, name, clientIP) {
    var httpXForwardedFor, ignoreIPrx, ip, sql;
    httpXForwardedFor = (req.get('x-forwarded-for') || '').split(/\s*,\s*/);
    ignoreIPrx = /^(127|192\.168|10|172\.(1[6-9]|2\d|3[01]))\./;
    while (httpXForwardedFor.length && clientIP.match(ignoreIPrx)) {
      clientIP = httpXForwardedFor.pop();
    }
    httpXForwardedFor = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = httpXForwardedFor.length; _i < _len; _i++) {
        ip = httpXForwardedFor[_i];
        if (ip === !clientIP && !ip.match(ignoreIPrx)) {
          _results.push(ip);
        }
      }
      return _results;
    })();
    httpXForwardedFor = httpXForwardedFor.length === 0 ? null : httpXForwardedFor.join(',');
    sql = 'INSERT INTO callback SET email_id=?, ctime=?, name=?, client_ip=?, http_user_agent=?, http_x_forwarded_for=?';
    return pg.connect(process.env.DATABASE_URL, function(err, client) {
      return client.query(sql, [email.email_id, Date.now(), name, clientIP, req.get('user-agent'), httpXForwardedFor], function(err, info) {
        if (err == null) {
          return emitter.emit("newCallback" + email.lookupCode);
        }
      });
    });
  };

  testCallbackEmail = function(req, res, email, callbackCode, name) {
    var ctime, emailData, sql, subject, _ref, _ref1;
    ctime = (_ref = req.body) != null ? _ref.ctime : void 0;
    emailData = (_ref1 = req.body) != null ? _ref1.emailData : void 0;
    subject = emailData.subject;
    sql = 'INSERT INTO callback SET email_id=?, ctime=?, name=?, email_subject=?';
    return pg.connect(process.env.DATABASE_URL, function(err, client) {
      return client.query(sql, [email.email_id, ctime, name, subject], function(err, info) {
        if (err == null) {
          return emitter.emit("newCallback" + email.lookupCode);
        }
      });
    });
  };

  testCallbackDNS = function(req, res, email, callbackCode, name) {
    var clientIP, ctime, sql, _ref, _ref1;
    ctime = (_ref = req.body) != null ? _ref.ctime : void 0;
    clientIP = (_ref1 = req.body) != null ? _ref1.clientIP : void 0;
    sql = 'INSERT INTO callback SET email_id=?, ctime=?, name=?, client_ip=?';
    return pg.connect(process.env.DATABASE_URL, function(err, client) {
      return client.query(sql, [email.email_id, ctime, name, clientIP], function(err, info) {
        if (err == null) {
          return emitter.emit("newCallback" + email.lookupCode);
        }
      });
    });
  };

  exports.emailStatusCallback = function(req, res) {
    var callbackCode, message, mtime, status;
    sendJSON(res, 'OK');
    callbackCode = req.params.callbackCode;
    status = req.body.status;
    message = req.body.message;
    mtime = req.body.mtime;
    return getResults('callback_code', callbackCode, function(err, email) {
      var sql;
      if ((err != null) || !(email != null)) {
        return;
      }
      sql = 'INSERT INTO email_log SET email_log_type_id=(SELECT email_log_type_id FROM email_log_type WHERE name=?), email_id=?, ctime=?, message=?';
      return pg.connect(process.env.DATABASE_URL, function(err, client) {
        return client.query(sql, [status, email.email_id, mtime, message], function(err, info) {
          if (err == null) {
            return emitter.emit("newEmailLog" + email.lookupCode);
          }
        });
      });
    });
  };

  exports.metaRefresh = function(req, res) {
    var emailLogId, listener, lookupCode, pid;
    lookupCode = req.params.lookupCode;
    emailLogId = req.params.emailLogId;
    pid = null;
    listener = function() {
      var _this = this;
      if (pid == null) {
        return;
      }
      clearTimeout(pid);
      pid = null;
      emitter.removeListener("newEmailLog" + lookupCode, listener);
      emitter.removeListener("newCallback" + lookupCode, listener);
      return setTimeout(function() {
        return res.redirect(302, "" + conf.site.path + lookupCode + "#testHits");
      }, 250);
    };
    pid = setTimeout(listener, 25000);
    emitter.on("newEmailLog" + lookupCode, listener);
    emitter.on("newCallback" + lookupCode, listener);
    return getNewEmailStatus(lookupCode, emailLogId, function(err, status, emailLogId) {
      if (status != null) {
        return listener();
      }
    });
  };

  exports.getResultsAJAX = function(req, res) {
    var callbackId, emailLogId, listener, lookupCode, pid,
      _this = this;
    lookupCode = req.params.lookupCode;
    emailLogId = req.params.emailLogId;
    callbackId = req.params.callbackId;
    pid = null;
    listener = function(data) {
      if (pid == null) {
        return;
      }
      clearTimeout(pid);
      pid = null;
      emitter.removeListener("newEmailLog" + lookupCode, listener);
      emitter.removeListener("newCallback" + lookupCode, listener);
      if (data != null) {
        return sendJSON(res, data);
      } else {
        return getNewData(lookupCode, emailLogId, callbackId, function(data, err) {
          return sendJSON(res, data);
        });
      }
    };
    pid = setTimeout(function() {
      return listener({});
    }, 25000);
    emitter.on("newEmailLog" + lookupCode, listener);
    emitter.on("newCallback" + lookupCode, listener);
    return getNewData(lookupCode, emailLogId, callbackId, function(data, err) {
      if (data.status || data.hits) {
        return listener(data);
      }
    });
  };

  exports.getResultsHTML = function(req, res) {
    var lookupCode;
    lookupCode = req.params.lookupCode;
    return getResults('lookup_code', lookupCode, function(err, email) {
      var countDown, opt;
      if (err != null) {
        return sendHTML(res, '500', {
          status: 500
        });
      }
      if (!(email != null)) {
        return sendHTML(res, 'results_404', {
          status: 404
        });
      }
      opt = {
        email: email,
        systemTime: Date.now(),
        emailLogId: 0,
        callbackId: 0
      };
      if (req.method === 'POST') {
        opt.js = true;
      }
      countDown = 2;
      tests.get(function(data) {
        opt.tests = data;
        if (--countDown === 0) {
          return sendHTML(res, 'results', opt);
        }
      });
      return getNewData(lookupCode, 0, 0, function(data, err) {
        var k, v;
        if (err != null) {
          return sendHTML(res, '500', {
            status: 500
          });
        }
        for (k in data) {
          v = data[k];
          opt[k] = v;
        }
        if (--countDown === 0) {
          return sendHTML(res, 'results', opt);
        }
      });
    });
  };

  getResults = function(lookupType, code, callback) {
    pg.connect(process.env.DATABASE_URL, function(err, client) {});
    return client.query("SELECT email_id, lookup_code AS lookupCode, ctime FROM email WHERE " + lookupType + "=?", [code], function(err, info) {
      if (err != null) {
        callback(err);
      }
      if (info.length) {
        info[0].ctimeAge = humanAge(info[0].ctime);
        return callback(err, info[0]);
      } else {
        return callback(err);
      }
    });
  };

  getNewEmailStatus = function(lookupCode, emailLogId, callback) {
    pg.connect(process.env.DATABASE_URL, function(err, client) {});
    return client.query('SELECT email_log.email_log_id AS emailLogId, email_log_type.name AS status, email_log.ctime AS mtime, email_log.message FROM email LEFT JOIN email_log ON email.email_id=email_log.email_id LEFT JOIN email_log_type ON email_log.email_log_type_id=email_log_type.email_log_type_id WHERE email.lookup_code=? AND email_log.email_log_id > ? ORDER BY email_log.email_log_id', [lookupCode, emailLogId], function(err, rows) {
      var log, mostRecentLog, _i, _len;
      if (err != null) {
        callback(err);
      }
      mostRecentLog = null;
      if (rows.length) {
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          log = rows[_i];
          emailLogId = log.emailLogId;
          if (!(mostRecentLog != null)) {
            mostRecentLog = log;
          } else if (mostRecentLog.status === 'queued') {
            if (log.mtime >= mostRecentLog.mtime) {
              mostRecentLog = log;
            }
          }
        }
        if (mostRecentLog != null) {
          mostRecentLog.mtimeAge = humanAge(mostRecentLog.mtime);
        }
      }
      return callback(err, mostRecentLog, emailLogId);
    });
  };

  getNewTestHits = function(lookupCode, callbackId, callback) {
    var sql;
    return sql = 'SELECT callback.callback_id AS callbackId, callback.ctime, callback.name, callback.client_ip AS clientIP, callback.http_user_agent AS httpUserAgent, callback.http_x_forwarded_for as httpXForwardedFor FROM email LEFT JOIN callback ON email.email_id=callback.email_id WHERE email.lookup_code=? AND callback.callback_id > ? ORDER BY callback.callback_id DESC';
  };

  pg.connect(process.env.DATABASE_URL, function(err, client) {
    return client.query(sql, [lookupCode, callbackId], function(err, rows) {
      var callbackId, hit, name, results, _i, _len;
      if ((err != null) || rows.length === 0) {
        return callback(err, null, callbackId);
      }
      results = {};
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        hit = rows[_i];
        name = hit.name;
        delete hit.name;
        hit.ctimeAge = minHumanAge(hit.ctime);
        if (results[name] == null) {
          results[name] = [];
        }
        results[name].push(hit);
      }
      callbackId = rows[0].callbackId;
      return callback(err, results, callbackId);
    });
  });

  getNewData = function(lookupCode, emailLogId, callbackId, callback) {
    var anyErr, countDown, opt, _ref;
    _ref = [2, {}, null], countDown = _ref[0], opt = _ref[1], anyErr = _ref[2];
    getNewEmailStatus(lookupCode, emailLogId, function(err, status, emailLogId) {
      if (err != null) {
        anyErr = err;
      }
      if (status != null) {
        opt.emailStatus = status;
      }
      if (emailLogId != null) {
        opt.emailLogId = emailLogId;
      }
      if (--countDown === 0) {
        return callback(opt, anyErr);
      }
    });
    return getNewTestHits(lookupCode, callbackId, function(err, hits, callbackId) {
      if (err != null) {
        anyErr = err;
      }
      if (hits != null) {
        opt.hits = hits;
      }
      if (callbackId != null) {
        opt.callbackId = callbackId;
      }
      if (--countDown === 0) {
        return callback(opt, anyErr);
      }
    });
  };

  humanAge = function(t) {
    var hour, min, parts, sec;
    sec = parseInt((Date.now() - t) / 1000);
    hour = parseInt(sec / 3600);
    sec -= hour * 3600;
    min = parseInt(sec / 60);
    sec -= min * 60;
    parts = [];
    if (hour) {
      parts.push("" + hour + " hour" + (hour === 1 ? '' : 's'));
    }
    if (hour || min) {
      parts.push("" + min + " minute" + (min === 1 ? '' : 's'));
    }
    parts.push("" + sec + " second" + (sec === 1 ? '' : 's'));
    return parts.join(', ') + ' ago';
  };

  minHumanAge = function(t) {
    var hour, min, sec;
    sec = parseInt((Date.now() - t) / 1000);
    hour = parseInt(sec / 3600);
    sec -= hour * 3600;
    min = parseInt(sec / 60);
    sec -= min * 60;
    if (hour) {
      return "" + hour + "h:" + min + "m:" + sec + "s";
    } else if (min) {
      return "" + min + "m:" + sec + "s";
    } else {
      return "" + sec + "s";
    }
  };

  sendHTML = function(res, name, obj) {
    if ((obj != null ? obj.conf : void 0) == null) {
      if (obj != null) {
        obj.conf = conf;
      }
    }
    res.charset = 'UTF-8';
    res.set('Content-Type', 'text/html');
    return res.render(name, obj);
  };

  sendJSON = function(res, obj) {
    res.charset = 'UTF-8';
    res.set('Content-Type', 'application/json');
    return res.end(JSON.stringify(obj));
  };

}).call(this);
